package org.jwat.tools.core;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;

import org.jwat.archive.ManagedPayload;
import org.jwat.common.ContentType;

/**
 * A file type identifier that wraps the libmagic dynamic library of the UNIX <code>file</code> identifier tool.
 *
 * @author hbian
 */
public class LibmagicIdentifier {

    /** Instance of Libmagic JNA wrapper. */
    private static transient LibmagicJnaWrapper libmagicWrapper;

    /** Magic database file extension. */
    private final static String MAGIC_DB_EXTENSION = ".mgc";

    /** The directory where source Magic definition files are stored. */
    private File magicFileDir = null;

    /** The compiled Magic file generated by this class. */
    private File compiledMagic = null;

    /**
     * Initialize module if it has not been done yet.
     * @throws IOException if an error occurs during initialization
     */
    public void checkIfInitialized() throws IOException {
       if (libmagicWrapper == null) {
            // Initialize libmagic wrapper.
            libmagicWrapper = new LibmagicJnaWrapper();

            String compiledMagicPath = null;
            if (this.magicFileDir != null) {
                // Magic source directory set. => Compile magic files.
                if (libmagicWrapper.compile(magicFileDir.getAbsolutePath()) != 0) {
                    throw new IOException("Magic file compile error: " + libmagicWrapper.getError());
                }
                // Look for compiled magic file. Its location varies according to
                // some compilation options of libmagic.
                // Was it stored in the current directory?
                String dbName = magicFileDir.getName() + MAGIC_DB_EXTENSION;
                File magicPath = new File(dbName);
                if (! magicPath.isFile()) {
                    // Nope! Must be in the parent dir. of the source definitions.
                    magicPath = new File(magicFileDir.getParentFile(), dbName);
                }
                compiledMagicPath = magicPath.getAbsolutePath();
                // Keep compiled file ref. for shutdown time cleanup.
                compiledMagic = magicPath;
                compiledMagic.deleteOnExit();
            }
            // Load magic definitions. 
            if (libmagicWrapper.load(compiledMagicPath) != 0) {
                String fileRef = (compiledMagicPath != null) ? "Magic database \"" + compiledMagicPath + '"' : "Default magic database";
                throw new IOException(fileRef + " load error: " + libmagicWrapper.getError());
            }
        }
    }

    /**
     * <i>Dependency injection</i> Sets the directory where to look
     * for Magic definition files.  If this property is set, this class
     * compiles the definition files prior attempting identification.
     * @param  magicDir   the directory holding the magic definition
     *                    files or <code>null</code> to use the default
     *                    already-compiled definitions.
     */
    public void setMagicFileDir(File magicDir) {
        magicFileDir = magicDir;
    }

    /**
     * Shuts down this instance, releasing used resources.
     */
    public void shutdown() {
        if (libmagicWrapper != null) {
            libmagicWrapper.close();
            libmagicWrapper = null;
        }
        if (compiledMagic != null) {
            // Delete compiled magic file.
            compiledMagic.delete();
            compiledMagic = null;
        }
    }

    /**
     * Identify the mimetype of the content of a managed payload object.
     * @param managedPayload managed payload object where the content to identify is located. 
     * @return a mimetype, null if none can be identified
     * @throws IOException an I/O exception is thrown if an error occurs while identifying a file
     */
    public ContentType identify(ManagedPayload managedPayload) throws IOException {
        checkIfInitialized();
        // Extract MIME type and encoding using libmagic.
        String mimeType = null;
        ContentType contentType = null;
        if (managedPayload.payloadLength > 0) {
            switch (managedPayload.type) {
            case 1:
                // In JDK 7 use a temp file, since using java Buffers hangs 
                // the processing by mixing the C arrays in multithread context
                File fTemp = File.createTempFile("JWAT-", "-MEMORY");
                try {
                    FileOutputStream fos = new FileOutputStream(fTemp, false);
                    FileChannel wc = fos.getChannel();
                    wc.write(managedPayload.getBuffer());
                    wc.close();
                    fos.close();
                    mimeType = libmagicWrapper.getMimeType(fTemp.getAbsolutePath());
                } finally {
                    fTemp.delete();
                }
                // ByteBuffer buffer = managedPayload.getBuffer();
                // mimeType = libmagicWrapper.getMimeType(buffer, buffer.limit());
                break;
            case 2:
                File file = managedPayload.getFile();
                mimeType = libmagicWrapper.getMimeType(file.getAbsolutePath());
                break;
            }
            if (mimeType != null) {
                contentType = ContentType.parseContentType(mimeType);
                /*
                if ("text/plain".equals(mimeType)) {
                    typeWithEncoding += "; charset=\"" + charset.toUpperCase() + '"';
                }
                // Else: ignore "charset=BINARY" present for non-text files.
                */
            }

        }
        return contentType;
    }

}
